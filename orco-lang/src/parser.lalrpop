grammar;
use crate::parser_utils;
use parser_utils::Named;
use orco::ir;

// Lexer
use crate::lexer::*;
use orco::ir::expression::Constant;
extern {
    type Location = usize;
    type Error = Error;

    enum Token {
        "fn" => Token::Keyword(Keyword::Fn),
        "extern" => Token::Keyword(Keyword::Extern),
        "return" => Token::Keyword(Keyword::Return),
        "ident" => Token::Ident(<String>),
        "constant" => Token::Constant(<Constant>),
        "(" => Token::Operator(Operator::LParen),
        ")" => Token::Operator(Operator::RParen),
        "[" => Token::Operator(Operator::LBracket),
        "]" => Token::Operator(Operator::RBracket),
        "{" => Token::Operator(Operator::LBrace),
        "}" => Token::Operator(Operator::RBrace),
        "," => Token::Operator(Operator::Comma),
        ":" => Token::Operator(Operator::Colon),
        ";" => Token::Operator(Operator::Semicolon),
        "->" => Token::Operator(Operator::Arrow),
        "+" => Token::Operator(Operator::Plus),
        "-" => Token::Operator(Operator::Minus),
        "*" => Token::Operator(Operator::Star),
        "/" => Token::Operator(Operator::Slash),
        "%" => Token::Operator(Operator::Percent),
    }
}

Comma<T>: Vec<T> = <v0:(<T> ",")*> <e1:T?> => v0.into_iter().chain(e1).collect();

// AST
// * Types
pub Type: ir::Type = {
    "ident" => if let Some(bytes) = parser_utils::numeric_type_size(&<>, "i") {
        ir::Type::Int(bytes)
    } else if let Some(bytes) = parser_utils::numeric_type_size(&<>, "u") {
        ir::Type::Unsigned(bytes)
    } else if let Some(bytes) = parser_utils::numeric_type_size(&<>, "f") {
        ir::Type::Float(bytes)
    } else {
        match <>.as_str() {
            "bool" => ir::Type::Bool,
            "char" => ir::Type::Char,
            _ => ir::Type::Custom(<>)
        }
    },
    ! => ir::Type::Error,
};

// * Expressions

BinaryOperator<Level>: ir::expression::BinaryOperator = {
    "+" if Level == "Additive" => ir::expression::BinaryOperator::Add,
    "-" if Level == "Additive" => ir::expression::BinaryOperator::Sub,
    "*" if Level == "Multiplicative" => ir::expression::BinaryOperator::Mul,
    "/" if Level == "Multiplicative" => ir::expression::BinaryOperator::Div,
    "%" if Level == "Multiplicative" => ir::expression::BinaryOperator::Mod,
};

pub LineExpression: ir::Expression = {
    #[precedence(level="0")]
    "constant" => ir::Expression::Constant(<>),

    #[precedence(level="1")] #[assoc(side="left")]
    Expression BinaryOperator<"Multiplicative"> Expression => ir::Expression::BinaryOp(<>),
    #[precedence(level="2")] #[assoc(side="left")]
    Expression BinaryOperator<"Additive"> Expression => ir::Expression::BinaryOp(<>),

    #[precedence(level="0")]
    <name:"ident"> "(" <args:Comma<Expression>> ")" => ir::Expression::FunctionCall { name,  args },

    #[precedence(level="3")]
    #[inline]
    "return" <Expression> => ir::Expression::Return(Box::new(<>)),
};

pub Block: ir::expression::Block = "{" <Statement*> "}" => ir::expression::Block::new(<>);

pub BlockExpression: ir::Expression = {
    Block => ir::Expression::Block(<>),
};

pub Expression: ir::Expression = {
    LineExpression,
    BlockExpression,
};

pub Statement: ir::Expression = {
    <LineExpression> ";",
    <BlockExpression> ";"?,
};

// * Items
pub FunctionSignature: Named<ir::item::function::Signature> =
        "fn" <name:"ident"> "(" <args:Comma<(<"ident"> ":" <Type>)>> ")" <return_type:("->" <Type>)?>
        => Named::new(name, ir::item::function::Signature::new(args, return_type.unwrap_or(ir::Type::unit())));

pub Function: Named<ir::item::function::Function> =
        <signature:FunctionSignature> <body:Block>
        => Named::new(signature.name, ir::item::function::Function::new(signature.value, body));

pub ExternalItem: Named<ir::Item> = {
    "extern" <FunctionSignature> ";" => <>.map(ir::Item::ExternalFunction),
};

pub Item: Named<ir::Item> = {
    Function => <>.map(ir::Item::Function),
    ExternalItem,
};

pub Module: ir::Module = Item* => ir::Module {
    items: <>.into_iter().map(|item| (item.name, item.value)).collect(),
};
