grammar;
use crate::parser_utils;
use parser_utils::Named;
use orco::ir;

// Lexer
use crate::lexer::*;
use orco::ir::expression::Constant;
extern {
    type Location = usize;
    type Error = Error;

    enum Token {
        "fn" => Token::Keyword(Keyword::Fn),
        "extern" => Token::Keyword(Keyword::Extern),
        "return" => Token::Keyword(Keyword::Return),
        "ident" => Token::Ident(<String>),
        "constant" => Token::Constant(<Constant>),
        "(" => Token::Operator(Operator::LParen),
        ")" => Token::Operator(Operator::RParen),
        "[" => Token::Operator(Operator::LBracket),
        "]" => Token::Operator(Operator::RBracket),
        "{" => Token::Operator(Operator::LBrace),
        "}" => Token::Operator(Operator::RBrace),
        "," => Token::Operator(Operator::Comma),
        ":" => Token::Operator(Operator::Colon),
        ";" => Token::Operator(Operator::Semicolon),
        "->" => Token::Operator(Operator::Arrow),
    }
}

Comma<T>: Vec<T> = <v0:(<T> ",")*> <e1:T?> => v0.into_iter().chain(e1).collect();

// AST
// * Types
pub Type: ir::Type = {
    "ident" => if let Some(bytes) = parser_utils::numeric_type_size(&<>, "i") {
        ir::Type::Int(bytes)
    } else if let Some(bytes) = parser_utils::numeric_type_size(&<>, "u") {
        ir::Type::Unsigned(bytes)
    } else if let Some(bytes) = parser_utils::numeric_type_size(&<>, "f") {
        ir::Type::Float(bytes)
    } else {
        match <>.as_str() {
            "bool" => ir::Type::Bool,
            "char" => ir::Type::Char,
            _ => ir::Type::Custom(<>)
        }
    },
    ! => ir::Type::Error,
};

// * Expressions
pub Block: ir::expression::Block = "{" <Statement*> "}" => ir::expression::Block::new(<>);

pub BlockExpression: ir::Expression = {
    Block => ir::Expression::Block(<>),
};

pub LineExpression: ir::Expression = {
    "return" <Expression> => ir::Expression::Return(Box::new(<>)),
    "constant" => ir::Expression::Constant(<>),
    <name:"ident"> "(" <args:Comma<Expression>> ")" => ir::Expression::FunctionCall { name,  args },
};

pub Expression: ir::Expression = {
    BlockExpression => <>,
    LineExpression => <>,
};

pub Statement: ir::Expression = {
    <BlockExpression> ";"? => <>,
    <LineExpression> ";" => <>,
};

// * Items
FunctionSignatureArgument: (String, ir::Type) = <"ident"> ":" <Type> => (<>);
ReturnType: ir::Type = "->" <Type> => <>;
pub FunctionSignature: Named<ir::item::function::Signature> =
        "fn" <name:"ident"> "(" <args:Comma<FunctionSignatureArgument>> ")" <return_type:ReturnType?>
        => Named::new(name, ir::item::function::Signature::new(args, return_type.unwrap_or(ir::Type::unit())));

pub Function: Named<ir::item::function::Function> =
        <signature:FunctionSignature> <body:Block>
        => Named::new(signature.name, ir::item::function::Function::new(signature.value, body));

pub ExternalItem: Named<ir::Item> = {
    "extern" <FunctionSignature> ";" => <>.map(ir::Item::ExternalFunction),
};

pub Item: Named<ir::Item> = {
    Function => <>.map(ir::Item::Function),
    ExternalItem => <>,
};

pub Module: ir::Module = Item* => ir::Module {
    items: <>.into_iter().map(|item| (item.name, item.value)).collect(),
};
